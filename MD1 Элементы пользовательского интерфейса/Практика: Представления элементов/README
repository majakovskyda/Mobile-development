Представления элементов

Цель работы
Познакомится с 
- основными приемами визуального представления элементов приложения, 
- управления их взаимным расположением, 
- оформлением, 
- работы с соответствующими атрибутами из XML и из Java кода. 

Методические указания

В Android SDK существует множество способов группировки элементов, которые называются представлениями (layout). 
На данном занятии мы изучим основные виды представлений.
Одним из наиболее простых в понимании является AbsoluteLayout (AL). 
Он обеспечивает абсолютное позиционирование элементов на экране. Вы указываете координаты для левого верхнего угла компонента.

Рассмотрим произвольный пример:

<AbsoluteLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/button1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_x="42dp"
        android:layout_y="62dp"
        android:text="Button">
    </Button>

    <TextView
        android:id="@+id/textView1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_x="142dp"
        android:layout_y="131dp"
        android:text="TextView">
    </TextView>

    <CheckBox
        android:id="@+id/checkBox1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_x="55dp"
        android:layout_y="212dp"
        android:text="CheckBox">
    </CheckBox>

    <RadioButton
        android:id="@+id/radioButton1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_x="171dp"
        android:layout_y="318dp"
        android:text="RadioButton">
    </RadioButton>
</AbsoluteLayout> (Фото №1)


Обратите внимание, что этот элемент считается устаревшим и не рекомендуется к использованию в серьезных приложения. 
Наверное, вторым по простоте является линейное представление. Оно размещает все элементы, содержащиеся в нем, последовательно. 
Создадим простое представление с тремя кнопками.

<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Button" />

    <Button
        android:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Button" />

    <Button
        android:id="@+id/button3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Button" />
</LinearLayout>

Обратите внимание на атрибут orientation элемента LinearLayout. Он задает направление элементов. 
В данном случае, три кнопки будут расположены вертикально, то есть одна под другой (Фото №2)

Давайте заменим расположение элементов на горизонтальное, изменив значение соответствующего атрибута:
android:orientation="horizontal" (Фото №3)
Мы увидим, что теперь элементы располагаются в ряд, горизонтально.

Помните, что вы можете вкладывать одно представление в другое, комбинируя в произвольном порядке 
типы упорядочения элементов и получая расположения произвольной сложности. 

Как пример, давайте расположим шесть кнопок в два ряда по три кнопки. 
Для этого используем только LinearLayout (хотя, существуют более явные способы добиться такого расположения):

<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <Button
            android:id="@+id/button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Button" />

        <Button
            android:id="@+id/button2"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Button" />

        <Button
            android:id="@+id/button3"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Button" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <Button
            android:id="@+id/button4"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Button" />
        <Button
            android:id="@+id/button5"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Button" />
        <Button
            android:id="@+id/button6"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Button" />
    </LinearLayout>
</LinearLayout> (Фото №4)

Еще одним типом расположения является RelativeLayout (RL). 
В этом виде представления каждый элемент может быть расположен определенным образом относительно другого указанного элемента. 
Используются следующие виды отношений (подробнее в документации):

p.s документация : https://developer.android.com/guide/topics/ui/layout/relative

1) слева, справа, сверху, снизу указанного элемента (layout_toLeftOf, layout_toRightOf, layout_above, layout_below)
2) выровненным по левому, правому, верхнему, нижнему краю указанного элемента (layout_alignLeft, layout_alignRight, layout_alignTop, layout_alignBottom)
3) выровненным по левому, правому, верхнему, нижнему краю родителя (layout_alignParentLeft, layout_alignParentRight, layout_alignParentTop, layout_alignParentBottom)
4) выровненным по центру вертикально, по центру горизонтально, по центру вертикально и горизонтально относительно родителя (layout_centerVertical, layout_centerHorizontal, layout_centerInParent)
Это представление удобно использовать по смыслу, когда у вас в приложении вид и положение на экране нескольких элементов должны быть координированы между собой. 
Например, мы хотим создать поле ввода на всю ширину экрана, а под ним две кнопки так, чтобы они были выровнены справа к границе этого поля ввода. 
Для этого проще всего описать это расположения с помощью атрибутов RelativeLayout:

<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/label"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Type here:">
    </TextView>

    <EditText
        android:id="@+id/entry"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_below="@+id/label"
        android:background="@android:drawable/editbox_background">
    </EditText>

    <Button
        android:id="@+id/ok"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentRight="true"
        android:layout_below="@+id/entry"
        android:layout_marginLeft="10dip"
        android:text="OK">
    </Button>

    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignTop="@+id/ok"
        android:layout_toLeftOf="@+id/ok"
        android:text="Cancel">
    </Button>
</RelativeLayout> (Фото №5)

Еще одним простым представлением является табличное (TableLayout). 
Оно состоит из строк и вложенных элементов и, в принципе, аналогично элементу <TABLE>  в языке HTML.
Давайте рассмотрим простой пример:

<TableLayout android:layout_height="wrap_content"
    xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="wrap_content">
    <TableRow
        android:layout_width="match_parent"
        android:layout_height="match_parent" >

        <Button
            android:id="@+id/button7"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Button" />

        <Button
            android:id="@+id/button8"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Button" />
    </TableRow>

    <TableRow
        android:layout_width="match_parent"
        android:layout_height="match_parent" >

        <Button
            android:id="@+id/button9"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Button" />
    </TableRow>
</TableLayout>

Здесь мы видим таблицу, состоящую из двух строк. В первой из них два элемента, во второй - один. (Фото №6)

Android SDK предоставляет широкий набор возможностей для настройки визуальных параметров отображения элементов. 
Большинство из них настраиваются изменением значений соответствующих атрибутов элементов XML-элемента. 
Про ширину (layout_width) и высоту (layout_height) мы уже немного знаем. Мы можем указывать для них абсолютные значения, 
а можем использовать константы. Разберем подробнее эти возможности.

Абсолютные значения:
Используются следующие единицы измерения (ЕИ):
dp - Density-independent Pixels. Абстрактная единица, позволяющая приложениям выглядеть одинаково на различных экранах и разрешениях;
sp - Scale-independent Pixels. То же, что и dp, только используется для размеров шрифта в элементах;
pt - 1/72 дюйма, определяется по физическому размеру экрана. Это единица из типографии;
px – пиксель, не рекомендуется использовать т. к. на разных экранах приложение будет выглядеть по-разному;
mm – миллиметр, определяется по физическому размеру экрана;
in – дюйм, определяется по физическому размеру экрана;
Константы
match_parent (fill_parent) – означает, что элемент займет всю доступную ему в родительском элементе ширину/высоту;
wrap_content – ширина/высота элемента будет определяться его содержимым;

Для примера рассмотрим простое линейное представление, состоящее из двух кнопок:

Давайте изменим значение атрибута:
android:layout_width="match_parent
Обратите внимание, что теперь кнопки расползлись на всю ширину экрана, причем они равны по ширине. 

<TableLayout
        android:layout_height="wrap_content"
        android:layout_width="match_parent"
        android:id="@+id/tableLayout1">
        <TableRow
            android:id="@+id/tableRow1"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content">

            <Button
                android:text="Button"
                android:id="@+id/button1"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content">
            </Button>
            <Button
                android:text="Button"
                android:id="@+id/button2"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content">
            </Button>
            <Button
                android:text="Button"
                android:id="@+id/button3"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content">
            </Button>
        </TableRow>
        <TableRow
            android:id="@+id/tableRow2"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content">
            <Button
                android:text="Button"
                android:id="@+id/button4"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content">
            </Button>
            <Button
                android:text="Margin"
                android:id="@+id/button5"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content">
            </Button>
            <Button
                android:text="Button"
                android:id="@+id/button6"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content">
            </Button>
        </TableRow>
        <TableRow
            android:id="@+id/tableRow3"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content">
            <Button
                android:text="Button"
                android:id="@+id/button7"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content">
            </Button>
            <Button
                android:text="Button"
                android:id="@+id/button8"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content">
            </Button>
            <Button
                android:text="Button"
                android:id="@+id/button9"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content">
            </Button>
        </TableRow>
    </TableLayout> (Фото №7)
    
В такой таблице все отступы будут особенно видны. 
Найдем среднюю кнопку (вторая во второй строке) и зададим ей отступ со всех сторон в 50 пикселей:
android:layout_margin="50dp" (Фото №8)

Так же как и в HTML, можно задавать отступы от элемента с каждой из четырех сторон независимо, например так:
android:layout_marginTop="50dp"
android:layout_marginLeft="20dp"

Параметр layout_gravity аналогичен выравниванию из Word или Excel. Удобнее всего продемонстрировать его с использованием FrameLayout. 
Все помещаемые в него элементы он по умолчанию помещает в левый верхний угол и никак их не выстраивает. 
Нам это очень подходит для демонстрации настроек выравнивания.
Продемонстрируем пять элементов, каждый со своей настройкой:

<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/frameLayout1"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <Button
        android:id="@+id/button1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="top|left"
        android:text="gravity = top left">
    </Button>
    <Button
        android:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="top|right"
        android:text="gravity = top right">
    </Button>
    <Button
        android:id="@+id/button3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom|left"
        android:text="gravity = bottom left">
    </Button>
    <Button
        android:id="@+id/button4"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="bottom|right"
        android:text="gravity = bottom right">
    </Button>
    <Button
        android:id="@+id/button5"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:text="gravity = center">
    </Button>
</FrameLayout> (Фото №9)

Значения атрибутов элементов приложения, как мы знаем, могут быть ссылками на ресурсы. 
Раньше мы использовали это только для выделения строк. Но этот же механизм можно использовать для создания аналога стилей в приложении. 
Давайте рассмотрим, как можно воспользоваться файлами ресурсов для изолированного хранения значений атрибутов оформления элементов. 
Заодно рассмотрим еще несколько атрибутов оформления.

Создадим простое окно, состоящее из двух одинаковых частей: верхней и нижней. В каждой расположен надпись и кнопка:

<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_height="match_parent"
    android:layout_width="match_parent"
    android:orientation="vertical">

    <LinearLayout
        android:layout_width="match_parent"
        android:id="@+id/llTop"
        android:orientation="vertical"
        android:layout_weight="1"
        android:layout_height="match_parent">

        <TextView
            android:text="TextView"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:id="@+id/tvTop"
            android:layout_marginTop="30dp">
        </TextView>
        <Button
            android:text="Button"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:id="@+id/btnTop"
            android:layout_width="wrap_content">
        </Button>
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:id="@+id/llBottom"
        android:orientation="vertical"
        android:layout_weight="1"
        android:layout_height="match_parent">

        <TextView
            android:text="TextView"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:id="@+id/tvBottom"
            android:layout_marginTop="30dp">
        </TextView>
        <Button
            android:text="Button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:id="@+id/btnBottom">
        </Button>
    </LinearLayout>
</LinearLayout> (Фото №10)

Теперь добавим оформления. Для того, чтобы все ресурсы, используемые для оформления этого приложения хранились вместе, 
создадим новый файл ресурсов и назовем его, скажем, MyRes:


